#include <cmath>
#include <cstddef>

#include <algorithm>
#include <array>
#include <iostream>
#include <vector>
#include <chrono>
#include <highfive/H5File.hpp>
#include <mgard/mdr.hpp>
#include <iostream>

#include "mgard/compress.hpp"


std::string filename = "/scratch/aoyagir/step1_500_test.h5";

/*
g++ compress_hdf5.cpp -I/usr/include/hdf5/serial -L/usr/lib/x86_64-linux-gnu/hdf5/serial/ -lhdf5 -lzstd -lmgard -lprotobuf
*/

int main() {

    // Open the file as read-only
    HighFive::File file(filename, HighFive::File::ReadOnly);

    // Get the dataset named "data"
    HighFive::DataSet dataset = file.getDataSet("data");

    // Retrieve the datatype of the dataset
    HighFive::DataType datatype = dataset.getDataType();
    std::cout << "Datatype: " << datatype.string() << std::endl;

    // Retrieve the dataspace of the dataset
    HighFive::DataSpace dataspace = dataset.getSpace();

    // Get the number of dimensions of the dataset
    std::size_t numDimensions = dataspace.getNumberDimensions();
    std::cout << "Number of dimensions: " << numDimensions << std::endl;

    // Get the size of each dimension
    auto dimensions = dataspace.getDimensions();
    std::cout << "Dimensions: ";
    for (const auto& dim : dimensions) {
        std::cout << dim << " ";
    }

    std::cout << std::endl;

    // slicing 

    long long unsigned int start_1 = 0;
    long long unsigned int start_2 = 0;
    long long unsigned int start_3 = 0;
    long long unsigned int start_4 = 0;

    long long unsigned int n1 = 1;
    long long unsigned int n2 = 512;
    long long unsigned int n3 = 512;
    long long unsigned int n4 = 128;

    long long int NumElements = n1*n2*n3*n4;
    std::vector<float> sim_data(NumElements);

            // For measuring compression time
    auto start = std::chrono::high_resolution_clock::now();

    dataset.select({start_1,start_2,start_3,start_4},
                    {n1, n2, n3, n4}).read(sim_data.data());

    // Stop measuring time
    auto end = std::chrono::high_resolution_clock::now();

    // Calculate the duration in milliseconds
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

    // // Print the execution time
    std::cout << "time_to_load " << n1 << " " 
    << n2 << " " << n3 << " " << n4 << " "
    << duration << " milliseconds" << std::endl;


    // We wrap the information about the mesh into an `mgard::TensorMeshHierarchy`
    // object. The first template parameter is the dimension. The second is the
    // datatype. `{N}` is the shape of the mesh/dataset, and `coordinates` is the
    // coordinate array. If the coordinate array is omitted, a uniform mesh on
    // `[0, 1]^{d}` will be used.

    std::cout << "creating mesh hierarchy ...";
    const mgard::TensorMeshHierarchy<4, float> hierarchy({n1,n2,n3,n4});
    std::cout << " done" << std::endl << std::endl;

    // Now we set the compression parameters. First we select the norm in which to
    // control the compression error. We choose from the family of supported norms
    // by setting a smoothness parameter `s`. `s = 0` corresponds to the `L²`
    // norm.
    const float s = 0;
    // Next we set the absolute error tolerance `τ`. The approximating dataset `ũ`
    // generated by MGARD will satisfy `‖u - ũ‖_{L²} ≤ τ`.
    float tolerance = 0.0000000000001;

    // We can now compress `u`. To do this, pass the mesh hierarchy, the function,
    // the smoothness parameter, and the error tolerance to `mgard::compress`.
    // Start measuring time

    for(int i = 0 ; i < 20 ; i++){

        // For measuring compression time
        auto start = std::chrono::high_resolution_clock::now();

        // Call the mgard::compress function
        const mgard::CompressedDataset<4, float> compressed =
            mgard::compress(hierarchy, sim_data.data(), s, tolerance);

        // Stop measuring time
        auto end = std::chrono::high_resolution_clock::now();

        // Calculate the duration in milliseconds
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

        // // Print the execution time
        std::cout << "Execution time: " << duration << " milliseconds" << std::endl;

        // Print the error tolerace
        std::cout << "Error tolerance:" << tolerance << std::endl;

        float original_data = (double)NumElements*sizeof(float)/1024/1024/1024;

        std::cout << "original data:" << original_data << "Gbytes" << std::endl;
        // `compressed` contains the compressed data buffer. We can query its size in
        // bytes with the `size` member function.
        std::cout << "compression ratio: "
                    << original_data*1024*1024*1024 / compressed.size()
                    << std::endl 
                    << original_data*1024*1024*1024
                    << " bytes -> " 
                    << compressed.size()
                    << " bytes"
                    <<  std::endl 
                    << "ThroughPut:"
                    << original_data / (duration*1000)
                    << " (GByte/sec)"
                    << "=" 
                    << original_data / (duration*1000) * 1024
                    << " MB/sec"
                    << std::endl << std::endl;

        tolerance *= 10;
    }

  return 0;
}
