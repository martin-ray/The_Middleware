#include <cmath>
#include <cstddef>

#include <algorithm>
#include <array>
#include <iostream>
#include <vector>
#include <chrono>
#include <highfive/H5File.hpp>
#include <mgard/mdr.hpp>
#include <iostream>

#include "mgard/compress.hpp"


std::string filename = "/home2/aoyagir/isotropic1024coarse/pressure2_hdf5/output_test.h5";

/*
g++ compress_hdf5.cpp -I/usr/include/hdf5/serial -L/usr/lib/x86_64-linux-gnu/hdf5/serial/ -lhdf5 -lzstd -lmgard -lprotobuf
*/

int main() {

    // Open the file as read-only
    HighFive::File file(filename, HighFive::File::ReadOnly);

    // Get the dataset named "data"
    HighFive::DataSet dataset = file.getDataSet("data");

    // Retrieve the datatype of the dataset
    HighFive::DataType datatype = dataset.getDataType();
    std::cout << "Datatype: " << datatype.string() << std::endl;

    // Retrieve the dataspace of the dataset
    HighFive::DataSpace dataspace = dataset.getSpace();

    // Get the number of dimensions of the dataset
    std::size_t numDimensions = dataspace.getNumberDimensions();
    std::cout << "Number of dimensions: " << numDimensions << std::endl;

    // Get the size of each dimension
    auto dimensions = dataspace.getDimensions();
    std::cout << "Dimensions: ";
    for (const auto& dim : dimensions) {
        std::cout << dim << " ";
    }

    std::cout << std::endl;

    // slicing 

    long long unsigned int start_1 = 0;
    long long unsigned int start_2 = 0;
    long long unsigned int start_3 = 0;
    long long unsigned int start_4 = 0;
    long long unsigned int start_5 = 0;

    long long unsigned int offset_1 = 1;
    long long unsigned int offset_2 = 1024;
    long long unsigned int offset_3 = 1024;
    long long unsigned int offset_4 = 1024;
    long long unsigned int offset_5 = 1;

    long long int NumElements = offset_1*offset_2*offset_3*offset_4;

    std::vector<float> result2(NumElements);

    dataset.select({start_1,start_2,start_3,start_4,start_5},
                    {offset_1, offset_2, offset_3, offset_4, offset_5}).read(result2.data());

    // We wrap the information about the mesh into an `mgard::TensorMeshHierarchy`
    // object. The first template parameter is the dimension. The second is the
    // datatype. `{N}` is the shape of the mesh/dataset, and `coordinates` is the
    // coordinate array. If the coordinate array is omitted, a uniform mesh on
    // `[0, 1]^{d}` will be used.

    std::cout << "creating mesh hierarchy ...";
    const mgard::TensorMeshHierarchy<5, float> hierarchy({1,100,100,100,1});
    std::cout << " done" << std::endl;

    // Now we set the compression parameters. First we select the norm in which to
    // control the compression error. We choose from the family of supported norms
    // by setting a smoothness parameter `s`. `s = 0` corresponds to the `L²`
    // norm.
    const float s = 0;
    // Next we set the absolute error tolerance `τ`. The approximating dataset `ũ`
    // generated by MGARD will satisfy `‖u - ũ‖_{L²} ≤ τ`.
    float tolerance = 0.0000000000001;

    // We can now compress `u`. To do this, pass the mesh hierarchy, the function,
    // the smoothness parameter, and the error tolerance to `mgard::compress`.
    // Start measuring time

    for(int i = 0 ; i < 20 ; i++){
        auto start = std::chrono::high_resolution_clock::now();

        // Call the mgard::compress function
        const mgard::CompressedDataset<5, float> compressed =
            mgard::compress(hierarchy, result2.data(), s, tolerance);

        // Stop measuring time
        auto end = std::chrono::high_resolution_clock::now();

        // Calculate the duration in milliseconds
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

        // // Print the execution time
        std::cout << "Execution time: " << duration << " milliseconds" << std::endl;

        // Print the error tolerace
        std::cout << "Error tolerance:" << tolerance << std::endl;

        // `compressed` contains the compressed data buffer. We can query its size in
        // bytes with the `size` member function.
        std::cout << "compression ratio: "
                    << static_cast<float>(NumElements * sizeof(result2.data())) / compressed.size()
                    << std::endl 
                    << NumElements * sizeof(result2.data())
                    << " bytes -> " 
                    << compressed.size()
                    << " bytes"
                    <<  std::endl 
                    << "ThroughPut:"
                    << (float)NumElements * sizeof(result2.data())/ duration*1000/1024.0/1024.0/1024.0
                    << " (GByte/sec)"
                    << std::endl << std::endl;

        tolerance *= 10;
    }

  return 0;
}
